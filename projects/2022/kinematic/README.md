# Recovering surface mass balance from kinematic observations

## reassurance

The point of the project is not to reach a particular destination!  It is to _help you learn fast from wherever you currently are_.  So please be honest with yourself about what you don't know, and please do ask about it!  Another student may know more programming than you, or have seen more differential equations, or have more glaciers background, or data-manipulation skills, or whatever.  That is irrelevant to my goal.  I just want to help you move forward as far as possible in one intense week.  Forward progress must be from things _you_ do understand into things _you_ do not yet understand!

## description

PROJECT 10: Recovering surface mass balance from kinematic observations

ADVISOR: Ed Bueler

DESCRIPTION: Remote observations of glaciers using visible and radar imaging allow increasingly-routine determination of ice surface elevation and ice surface velocity.  On the other hand, surface mass balance (SMB) rates can be hard to observe remotely, for instance in ablation areas and/or firn areas with ice lenses.  The surface kinematical equation (SKE) is worth understanding in this regard, in addition to its application to modeling glacier evolution.  We will use the SKE to invert time-dependent synthetic observations to extract SMB, a feat attempted before (e.g. Gudmundsson & Bauder, 1999).  A newly-discovered form of the SKE makes the topic worth a second look.  Simplified 1D geometry and the linear nature of the problem make it achievable in a week-long project.

SOFTWARE REQUIREMENTS: Matlab or Octave or Python/numpy, _running locally on your machine_.

REQUIRED STUDENT BACKGROUND: Exposure to differential equations and linear algebra.

## references and reading

Three reference PDFs are available in the current directory:

  * E. Bueler (2022a). **A synthetic, time-dependent glacier for testing surface kinematical inversion**, unpublished.  _This is_ `synglac.pdf` _mentioned below._
  * E. Bueler (2022b). **A new kinematical conservation law for glaciers**, unpublished.   _This is_ `newlaw.pdf`. _An early draft only._
  * G. H. Gudmundsson & A. Bauder (1999). **Towards an indirect determination of the massâ€balance distribution of glaciers using the kinematic boundary condition**, Geografiska Annaler: Series A, Physical Geography, 81(4), 575-583.  _Shows inversion of the SKE, and addresses how to recover the vertical surface velocity._

## a possible project procedure

The Python script `glacier.py` computes all the relevant surface fields of a synthetic, time-varying glacier.  The PDF `synglac.pdf`, generated by the LaTeX files in the `doc/` directory, shows the formulas used in this case.

My suggestion for Project 10 is that you use `glacier.py` to generate an initial test of inversion using the kinematic conservation law (KCL), a new form of the surface kinematical equation (SKE).  The following paragraphs are documentation to help you do that.  In fact this sketch is just enough to get started.  Many choices and details remain.

### discretizing space-time

The brief sketch in `synglac.pdf` shows the KCL as an integral equation with the unknown lumped CMB $\tilde a(t,x)$ on the left; see equation (3).  This integral equation becomes a linear system if we discretize.

In particular, suppose the time-space rectangle $[0,T]\times[-L,L]$ is divided by grid spaces $\Delta t$ and $\Delta x$, giving $J$ intervals in time and $K$ intervals in space.  Suppose we represent the unknown field $\tilde a$ by its $n = JK$ values at the centers of the cells which have dimensions $\Delta t \times \Delta x$.  These $n$ values of $\tilde a$ are the unknowns.

The integrals on the left and right of equation (3) can (and must) be approximated.  I would suggest, for simplicity, using the midpoint rule for this purpose, that is, for each cell you use the cell-center point value.

An overdetermined system arises if you discretize the unknown $\tilde a$ on a coarse mesh of cells, but you compute integrals on a finer mesh of cells.  Once things are working with the exact values, one can add noise to the "observed" fields, in which case solving the overdetermined system will be stable with respect to that noise.

### evaluating formulas from the synthetic glacier code

To evaluate the integrals in equation (3) you will need to evaluate the "observed" fields $s(t,x)$, $u|_s(t,x)$, and $\frac{\partial s}{\partial x}(t,x)$.  This is the purpose of the script `glacier.py`.

You can see visualizations of these fields just by running the script at the Python command line:

        >> run glacier.py

However, the right thing to do for the project is to import and use the functions you need.  Here is an example which does that:

        >> import numpy as np
        >> import matplotlib.pyplot as plt
        >> from glacier import s, us, dsdx, T, L_0
        >> x = np.linspace(-L_0,L_0,101)
        >> plt.plot(x,s(T/2,x))
        >> plt.show()

If you import functions this way from `glacier.py` then you can build a gridded (discretized) version of the integrals on the left and right sides of (3), and set up an overdetermined linear system which you can solve by least squares.

### overdetermined systems and least squares

Following the brief sketch in `synglac.pdf`, I propose that you build an overdetermined linear system from discretizing $t,x$ as described above.

An overdetermined system has $m$ equations and $n$ unknowns where $m>n$.  For example, if the equation is

$$A x = b$$

then $x$ is a column vector with $n$ entries and $b$ is a column vector with $m$ entries, and $A$ is a matrix with $m$ rows and $n$ columns.  The equation "$Ax=b$" should really be in quotes because we don't expect an exact solution.  Instead we want the least-squares solution where we find $x$ so that $Ax$ and $b$ are as close to being the same vector as possible, that is, so that the norm of the difference $\|Ax-b\|$ is small.  Since norms are usually computed by summing the squares of the entries, followed by square root, this is the least-squares idea.

The script `demos/lstsq_demo.py` sets up a system of $m=3$ equations and $n=2$ unknowns and it solves it by using the `lstsq()` function in `scipy.linalg`.  Please understand this example before proceeding.

Optionally you may want to understand and use the singular value decomposition (SVD), which is one way to handle least-squares problems.  See `demos/svd_demo.py`.
